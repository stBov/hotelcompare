目标是 60000多数据根据 酒店名称 酒店电话 酒店地址，两两判断，是否为重复酒店算法。

数据需预处理为5列，酒店名称，酒店地址，酒店电话，酒店GUID，城市GUID

1.首先是6W数据都加载到内存中，然后一个一个比较对应的算法结果，得出对应的比对数据结果。
此方法会比较慢，单线程，笛卡尔积。运算量大。因为其中有用到IK分词器相关代码，
每次都需要去重复init相应IK对象，所以没有跑成功一次
2.将数据进行分片拆分，此方法有一个缺点，只能保证一个片中两两比较，无法对整体进行比较，
后来进行优化后，分片后比对6W数据，其中核心比对算法没有优化，所以仍不能成功
3.将分片后的结果进行了多线程处理计算，通过Callable 带返回值多线程方法，批量得出结果集，
进行封装处理。此处理方式仍然计算量大。30秒才能跑一次分片，不理想
4.将数据进行了二次筛选，将城市GUID放入txt文件中，读取不同城市guid，进行数据整体拆分，
（考虑到酒店相似，为某个城市的酒店相似）拆分后，使用多线程分片跑数据，可以实际得出计算结果，
但是仍然是数据执行缓慢，不理想，但是已经有了一个解决方案
5.通过 jvisualvm.exe vm工具，查看占用线程时间较多的为init创建IK分词对象的方法，
所以考虑在计算前将不同城市GUID下的酒店名称，通过一次创建分词记录到hashmap中，
在比对算法中get相应的结果计算（key值为酒店GUID，value为Vector<String>数组）
此方法明显降低了计算的时间，实测3分钟跑完所以600多城市
6.在第5种方式时，出现了线程崩溃问题，所以只能断开后手动删除 城市GUID的txt文件记录，
达到记录问题接着跑问题。后续通过得到，因为使用的是hashmap分词结果查询（get）,
此时是线程不安全的，后来通过查阅，得到需要使用ConcurrentHashMap 来达到线程安全。
7.后续又出现线程崩溃问题，解决是底层IK分词中用到的hashmap导致。

思考：
1.多线程的线程池设置
线程数=1+（IO时间/内存时间）

2.hashmap线程不安全，多线程务必不要使用，如果使用map需使用加锁的ConcurrentHashMap

3.通过对数据的二次筛选来达到降低计算过程的目的，多线程的加入，可以极大的缩短计算的时间，
但是需要考虑线程的数量，来保证线程的来回切换所耗费的时间消耗。

4.如果计算不理想，可以通过jvisualvm.exe，jdk自带的vm工具来查看调优。必要时可以通过重写
线程占用时间长的方法来进行降低时间。